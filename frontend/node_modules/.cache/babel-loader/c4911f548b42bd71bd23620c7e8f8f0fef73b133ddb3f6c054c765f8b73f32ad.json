{"ast":null,"code":"/**\n * API Service\n * Handles communication with the backend at http://localhost:5000/api/chat\n */\n\n// Backend URL - Make sure this matches where your backend is running\nconst BACKEND_URL = \"http://localhost:5001/api/chat\";\n;\n\n// Store session ID to maintain conversation continuity\nlet currentSessionId = null;\n\n/**\n * Get AI Message from Backend\n * Sends user query to backend and returns formatted response\n * @param {string} userQuery - The user's message\n * @returns {Promise<Object>} - Formatted message object with role and content\n */\nexport const getAIMessage = async userQuery => {\n  try {\n    // 1. Prepare request payload\n    const payload = {\n      message: userQuery,\n      sessionId: currentSessionId // Include session ID if we have one (for conversation continuity)\n    };\n\n    console.log(\"📤 Sending to backend:\", payload); // Debug log\n\n    // 2. Send POST request to backend\n    const response = await fetch(BACKEND_URL, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(payload)\n    });\n    console.log(\"📥 Response status:\", response.status); // Debug log\n\n    // 3. Check if response is OK\n    if (!response.ok) {\n      throw new Error(`Backend error: ${response.status}`);\n    }\n\n    // 4. Parse response JSON\n    const data = await response.json();\n    console.log(\"📥 Response data:\", data); // Debug log\n\n    // 5. Save session ID for next request (maintains conversation)\n    if (data.sessionId) {\n      currentSessionId = data.sessionId;\n      console.log(\"💾 Session ID saved:\", currentSessionId); // Debug log\n    }\n\n    // 6. Format response based on response type\n    const formattedMessage = formatBackendResponse(data);\n    return formattedMessage;\n  } catch (error) {\n    // Handle errors\n    console.error(\"❌ Error calling backend:\", error);\n    return {\n      role: \"assistant\",\n      content: `Sorry, I encountered an error: ${error.message}. Please make sure the backend is running on http://localhost:5000`\n    };\n  }\n};\n\n/**\n * Format Backend Response\n * Takes the backend response and formats it based on response type\n * @param {Object} data - Response data from backend\n * @returns {Object} - Formatted message object\n */\nconst formatBackendResponse = data => {\n  // Check if request was successful\n  if (!data.success) {\n    var _data$error;\n    return {\n      role: \"assistant\",\n      content: ((_data$error = data.error) === null || _data$error === void 0 ? void 0 : _data$error.message) || \"An error occurred\"\n    };\n  }\n  const response = data.response;\n  let content = \"\";\n\n  // Format content based on response type\n  switch (response.type) {\n    // Text response - just return the content\n    case \"text\":\n      content = response.content;\n      break;\n\n    // Product results - format as list\n    case \"product_results\":\n      content = formatProductResults(response);\n      break;\n\n    // Installation guide - format with steps\n    case \"installation_guide\":\n      content = formatInstallationGuide(response);\n      break;\n\n    // Troubleshooting - format with causes and solutions\n    case \"troubleshooting\":\n      content = formatTroubleshooting(response);\n      break;\n\n    // Out of scope - friendly deflection\n    case \"out_of_scope\":\n      content = response.content;\n      break;\n\n    // Error response\n    case \"error\":\n      content = `Error: ${response.content}`;\n      break;\n\n    // Unknown type - just show content\n    default:\n      content = response.content;\n  }\n  return {\n    role: \"assistant\",\n    content: content\n  };\n};\n\n/**\n * Format Product Results\n * Formats product data into readable list\n * @param {Object} response - Response with product data\n * @returns {string} - Formatted product list\n */\nconst formatProductResults = response => {\n  const {\n    content,\n    data\n  } = response;\n  if (!data || !data.products || data.products.length === 0) {\n    return content || \"No products found\";\n  }\n  let formatted = content + \"\\n\\n\";\n  data.products.forEach((product, index) => {\n    formatted += `**${index + 1}. ${product.name}**\\n`;\n    formatted += `   ID: ${product.id}\\n`;\n    formatted += `   Price: $${product.price}\\n`;\n    formatted += `   Description: ${product.description}\\n`;\n    if (product.compatibility && product.compatibility.length > 0) {\n      formatted += `   Compatible with: ${product.compatibility.join(\", \")}\\n`;\n    }\n    formatted += `   In Stock: ${product.inStock ? \"Yes\" : \"No\"}\\n\\n`;\n  });\n  return formatted;\n};\n\n/**\n * Format Installation Guide\n * Formats installation steps into readable format\n * @param {Object} response - Response with installation data\n * @returns {string} - Formatted installation guide\n */\nconst formatInstallationGuide = response => {\n  const {\n    content,\n    data\n  } = response;\n  if (!data || !data.steps || data.steps.length === 0) {\n    return content || \"No installation steps available\";\n  }\n  let formatted = content + \"\\n\\n\";\n  formatted += `⏱️ Estimated Time: ${data.estimatedTime} minutes\\n`;\n  formatted += `📊 Difficulty: ${data.difficulty}\\n\\n`;\n  data.steps.forEach(step => {\n    formatted += `**Step ${step.step}: ${step.instruction}**\\n`;\n    if (step.tools && step.tools.length > 0) {\n      formatted += `   🔧 Tools needed: ${step.tools.join(\", \")}\\n`;\n    }\n    if (step.tips && step.tips.length > 0) {\n      formatted += `   💡 Tips:\\n`;\n      step.tips.forEach(tip => {\n        formatted += `      - ${tip}\\n`;\n      });\n    }\n    if (step.warnings && step.warnings.length > 0) {\n      formatted += `   ⚠️ Warnings:\\n`;\n      step.warnings.forEach(warning => {\n        formatted += `      - ${warning}\\n`;\n      });\n    }\n    formatted += \"\\n\";\n  });\n  return formatted;\n};\n\n/**\n * Format Troubleshooting\n * Formats troubleshooting causes and solutions\n * @param {Object} response - Response with troubleshooting data\n * @returns {string} - Formatted troubleshooting guide\n */\nconst formatTroubleshooting = response => {\n  const {\n    content,\n    data\n  } = response;\n  let formatted = content + \"\\n\\n\";\n\n  // Format possible causes\n  if (data && data.possibleCauses && data.possibleCauses.length > 0) {\n    formatted += \"**Possible Causes:**\\n\\n\";\n    data.possibleCauses.forEach((cause, index) => {\n      formatted += `${index + 1}. **${cause.cause}** (${cause.probability} probability)\\n`;\n      formatted += `   Description: ${cause.description}\\n`;\n      formatted += `   Fix: ${cause.fix}\\n\\n`;\n    });\n  }\n\n  // Format suggested solutions\n  if (data && data.suggestedSolutions && data.suggestedSolutions.length > 0) {\n    formatted += \"**Suggested Solutions:**\\n\\n\";\n    data.suggestedSolutions.forEach((solution, index) => {\n      formatted += `**Solution ${index + 1}: ${solution.title}**\\n`;\n      if (solution.steps && solution.steps.length > 0) {\n        solution.steps.forEach((step, stepIndex) => {\n          formatted += `   ${stepIndex + 1}. ${step}\\n`;\n        });\n      }\n      formatted += `   ⏱️ Estimated Time: ${solution.estimatedTime} minutes\\n`;\n      if (solution.recommendedParts && solution.recommendedParts.length > 0) {\n        formatted += `   🛠️ Recommended Parts: ${solution.recommendedParts.join(\", \")}\\n`;\n      }\n      formatted += \"\\n\";\n    });\n  }\n  return formatted;\n};\n\n/**\n * Reset Session\n * Call this if you want to start a new conversation\n */\nexport const resetSession = () => {\n  currentSessionId = null;\n  console.log(\"🔄 Session reset\");\n};\n\n/**\n * Get Current Session ID\n * For debugging purposes\n */\nexport const getCurrentSessionId = () => {\n  return currentSessionId;\n};","map":{"version":3,"names":["BACKEND_URL","currentSessionId","getAIMessage","userQuery","payload","message","sessionId","console","log","response","fetch","method","headers","body","JSON","stringify","status","ok","Error","data","json","formattedMessage","formatBackendResponse","error","role","content","success","_data$error","type","formatProductResults","formatInstallationGuide","formatTroubleshooting","products","length","formatted","forEach","product","index","name","id","price","description","compatibility","join","inStock","steps","estimatedTime","difficulty","step","instruction","tools","tips","tip","warnings","warning","possibleCauses","cause","probability","fix","suggestedSolutions","solution","title","stepIndex","recommendedParts","resetSession","getCurrentSessionId"],"sources":["/Users/utkarshprajapati/Documents/GitHub/Parts_Specific_AI_Agent/frontend/src/api/api.js"],"sourcesContent":["/**\n * API Service\n * Handles communication with the backend at http://localhost:5000/api/chat\n */\n\n// Backend URL - Make sure this matches where your backend is running\nconst BACKEND_URL = \"http://localhost:5001/api/chat\";;\n\n// Store session ID to maintain conversation continuity\nlet currentSessionId = null;\n\n/**\n * Get AI Message from Backend\n * Sends user query to backend and returns formatted response\n * @param {string} userQuery - The user's message\n * @returns {Promise<Object>} - Formatted message object with role and content\n */\nexport const getAIMessage = async (userQuery) => {\n  try {\n    // 1. Prepare request payload\n    const payload = {\n      message: userQuery,\n      sessionId: currentSessionId, // Include session ID if we have one (for conversation continuity)\n    };\n\n    console.log(\"📤 Sending to backend:\", payload); // Debug log\n\n    // 2. Send POST request to backend\n    const response = await fetch(BACKEND_URL, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(payload),\n    });\n\n    console.log(\"📥 Response status:\", response.status); // Debug log\n\n    // 3. Check if response is OK\n    if (!response.ok) {\n      throw new Error(`Backend error: ${response.status}`);\n    }\n\n    // 4. Parse response JSON\n    const data = await response.json();\n\n    console.log(\"📥 Response data:\", data); // Debug log\n\n    // 5. Save session ID for next request (maintains conversation)\n    if (data.sessionId) {\n      currentSessionId = data.sessionId;\n      console.log(\"💾 Session ID saved:\", currentSessionId); // Debug log\n    }\n\n    // 6. Format response based on response type\n    const formattedMessage = formatBackendResponse(data);\n\n    return formattedMessage;\n  } catch (error) {\n    // Handle errors\n    console.error(\"❌ Error calling backend:\", error);\n\n    return {\n      role: \"assistant\",\n      content: `Sorry, I encountered an error: ${error.message}. Please make sure the backend is running on http://localhost:5000`,\n    };\n  }\n};\n\n/**\n * Format Backend Response\n * Takes the backend response and formats it based on response type\n * @param {Object} data - Response data from backend\n * @returns {Object} - Formatted message object\n */\nconst formatBackendResponse = (data) => {\n  // Check if request was successful\n  if (!data.success) {\n    return {\n      role: \"assistant\",\n      content: data.error?.message || \"An error occurred\",\n    };\n  }\n\n  const response = data.response;\n  let content = \"\";\n\n  // Format content based on response type\n  switch (response.type) {\n    // Text response - just return the content\n    case \"text\":\n      content = response.content;\n      break;\n\n    // Product results - format as list\n    case \"product_results\":\n      content = formatProductResults(response);\n      break;\n\n    // Installation guide - format with steps\n    case \"installation_guide\":\n      content = formatInstallationGuide(response);\n      break;\n\n    // Troubleshooting - format with causes and solutions\n    case \"troubleshooting\":\n      content = formatTroubleshooting(response);\n      break;\n\n    // Out of scope - friendly deflection\n    case \"out_of_scope\":\n      content = response.content;\n      break;\n\n    // Error response\n    case \"error\":\n      content = `Error: ${response.content}`;\n      break;\n\n    // Unknown type - just show content\n    default:\n      content = response.content;\n  }\n\n  return {\n    role: \"assistant\",\n    content: content,\n  };\n};\n\n/**\n * Format Product Results\n * Formats product data into readable list\n * @param {Object} response - Response with product data\n * @returns {string} - Formatted product list\n */\nconst formatProductResults = (response) => {\n  const { content, data } = response;\n\n  if (!data || !data.products || data.products.length === 0) {\n    return content || \"No products found\";\n  }\n\n  let formatted = content + \"\\n\\n\";\n\n  data.products.forEach((product, index) => {\n    formatted += `**${index + 1}. ${product.name}**\\n`;\n    formatted += `   ID: ${product.id}\\n`;\n    formatted += `   Price: $${product.price}\\n`;\n    formatted += `   Description: ${product.description}\\n`;\n    if (product.compatibility && product.compatibility.length > 0) {\n      formatted += `   Compatible with: ${product.compatibility.join(\", \")}\\n`;\n    }\n    formatted += `   In Stock: ${product.inStock ? \"Yes\" : \"No\"}\\n\\n`;\n  });\n\n  return formatted;\n};\n\n/**\n * Format Installation Guide\n * Formats installation steps into readable format\n * @param {Object} response - Response with installation data\n * @returns {string} - Formatted installation guide\n */\nconst formatInstallationGuide = (response) => {\n  const { content, data } = response;\n\n  if (!data || !data.steps || data.steps.length === 0) {\n    return content || \"No installation steps available\";\n  }\n\n  let formatted = content + \"\\n\\n\";\n  formatted += `⏱️ Estimated Time: ${data.estimatedTime} minutes\\n`;\n  formatted += `📊 Difficulty: ${data.difficulty}\\n\\n`;\n\n  data.steps.forEach((step) => {\n    formatted += `**Step ${step.step}: ${step.instruction}**\\n`;\n\n    if (step.tools && step.tools.length > 0) {\n      formatted += `   🔧 Tools needed: ${step.tools.join(\", \")}\\n`;\n    }\n\n    if (step.tips && step.tips.length > 0) {\n      formatted += `   💡 Tips:\\n`;\n      step.tips.forEach((tip) => {\n        formatted += `      - ${tip}\\n`;\n      });\n    }\n\n    if (step.warnings && step.warnings.length > 0) {\n      formatted += `   ⚠️ Warnings:\\n`;\n      step.warnings.forEach((warning) => {\n        formatted += `      - ${warning}\\n`;\n      });\n    }\n\n    formatted += \"\\n\";\n  });\n\n  return formatted;\n};\n\n/**\n * Format Troubleshooting\n * Formats troubleshooting causes and solutions\n * @param {Object} response - Response with troubleshooting data\n * @returns {string} - Formatted troubleshooting guide\n */\nconst formatTroubleshooting = (response) => {\n  const { content, data } = response;\n\n  let formatted = content + \"\\n\\n\";\n\n  // Format possible causes\n  if (data && data.possibleCauses && data.possibleCauses.length > 0) {\n    formatted += \"**Possible Causes:**\\n\\n\";\n\n    data.possibleCauses.forEach((cause, index) => {\n      formatted += `${index + 1}. **${cause.cause}** (${cause.probability} probability)\\n`;\n      formatted += `   Description: ${cause.description}\\n`;\n      formatted += `   Fix: ${cause.fix}\\n\\n`;\n    });\n  }\n\n  // Format suggested solutions\n  if (data && data.suggestedSolutions && data.suggestedSolutions.length > 0) {\n    formatted += \"**Suggested Solutions:**\\n\\n\";\n\n    data.suggestedSolutions.forEach((solution, index) => {\n      formatted += `**Solution ${index + 1}: ${solution.title}**\\n`;\n\n      if (solution.steps && solution.steps.length > 0) {\n        solution.steps.forEach((step, stepIndex) => {\n          formatted += `   ${stepIndex + 1}. ${step}\\n`;\n        });\n      }\n\n      formatted += `   ⏱️ Estimated Time: ${solution.estimatedTime} minutes\\n`;\n\n      if (solution.recommendedParts && solution.recommendedParts.length > 0) {\n        formatted += `   🛠️ Recommended Parts: ${solution.recommendedParts.join(\", \")}\\n`;\n      }\n\n      formatted += \"\\n\";\n    });\n  }\n\n  return formatted;\n};\n\n/**\n * Reset Session\n * Call this if you want to start a new conversation\n */\nexport const resetSession = () => {\n  currentSessionId = null;\n  console.log(\"🔄 Session reset\");\n};\n\n/**\n * Get Current Session ID\n * For debugging purposes\n */\nexport const getCurrentSessionId = () => {\n  return currentSessionId;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}